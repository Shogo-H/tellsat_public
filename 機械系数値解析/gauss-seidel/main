/*

ガウスザイデル法を用いて，定数aを含む連立方程式の解を解き，解が収束するaの範囲を求める．
aが収束する範囲は，
　　a<=-3.6
	-3.22<=a<=-1.45
	-0.98<=a<=1.53
	1.82<=a<=2.16
	2.82<=a<=3.32
	3.7<=a
*/

#include <stdio.h>
#include <math.h>
#define N (5)	// 連立方程式の大きさ
#define EPS (1e-10)	// 計算誤差の許容値
#define limit (1000)	//計算回数の制限

int main(void){
	double a;
	double A[N+1][N+1], x[N+1], b[N+1];
	double dx, absx, sum, next;
	int i,j;
	int k;	//デバッグのscanf用
	int n;	//計算回数
	
	///////////////////////////////////////////////////////aの値を変えてみる
	for(a=-10.0;a<=10;a+=0.01){

		//係数行列
		A[1][1]=a-3.0;	A[1][2]=1.0;	A[1][3]=1.0;	A[1][4]=1.0;	A[1][5]=1.0;
		A[2][1]=1.0;	A[2][2]=-a+2.0;	A[2][3]=2.0;	A[2][4]=1.0;	A[2][5]=1.0;
		A[3][1]=1.0;	A[3][2]=1.0;	A[3][3]=a+2.0;	A[3][4]=1.0;	A[3][5]=1.0;
		A[4][1]=1.0;	A[4][2]=1.0;	A[4][3]=1.0;	A[4][4]=a+3.0;	A[4][5]=1.0;
		A[5][1]=1.0;	A[5][2]=1.0;	A[5][3]=1.0;	A[5][4]=1.0;	A[5][5]=-a-2.0;

		//同次項
		b[1]=a+1.0;
		b[2]=-a+7.0;
		b[3]=a+6.0;
		b[4]=a+7.0;
		b[5]=-a+2.0;

		//近似解の初期化
		x[1]=0.0;
		x[2]=0.0;
		x[3]=0.0;
		x[4]=0.0;
		x[5]=0.0;
		
		//反復回数の初期化
		n=0;

		//反復計算
		do{
			dx=0.0;
			absx=0.0;
			for(i=1;i<=N;i++){
				sum=0;
					for(j=1;j<=N;j++){
					if(i != j){
						sum+=A[i][j]*x[j];
					}
				}
				next=1.0/A[i][i]*(b[i]-sum);   // 反復計算後の近似解
				dx+=fabs(next-x[i]);           // 近似解の変化量を加算
				absx+=fabs(next);              // 近似解の総和計算
				x[i]=next;                     // 新しい近似解を代入
			}
			n++;
		}while(dx/absx > EPS && n<limit);            // 計算続行条件
			
		if(n>999){
			printf("***************************************a=%f\n",a);
		}else{
			//printf("a=%f\n",a);
		}
	
	}
	//////////////////////////////////
	printf("おわり,%f,%f,%f,%f,%f",x[1],x[2],x[3],x[4],x[5]);
	scanf("%d", &k);
	return 0;
}
